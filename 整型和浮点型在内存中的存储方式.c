//判断当前数据在内存中的存储方式，是大端还是小端 
/*
#include<stdio.h>
int check_sys()
{
	int a = 1;
	//大端存储为0x00000001
	//小端存储为0x01000000所以判断第一个字节的值就可以判断出大端小端 
	char* p = (char*)&a;//指向a的第一个字节的地址//将&a直接强制类型转换 
	return *p;//返回第一个字节的值，让外面去判断 
}
int check_sys()
{
	int a = 1;
	//return *(char*)&a;
	return (char)a; 
}
int main()
{
	int ret = check_sys();
	int i = 0x11223344; 
	//小端存储为44332211
	//大端存储为11223344 
	if(1==ret)
	{
		printf("小端\n");
	}
	else
	    printf("大端\n"); 
	return 0;
}*/
//unsigned无符号型数 
/*
#include<stdio.h>
int main()
{
	char a = -128;
	//1000000000000000000000010000000 -- -128的原码
	//1111111111111111111111110000000 -- -128的补码
	//10000000 -- char类型的-128的补码
	//1111111111111111111111110000000 -- 整型提升后的补码此时就是%u打印的值--无符号型的原反补码相同，就是无符号位 
	//1111111111111111111111101111111 --反码
	//1000000000000000000000010000000 -- 原码，此时就是%d打印的值 
	//printf("%u\n%d\n", a, a);//%u代表打印无符号的整型数
	char b = 128;//char类型的范围是-128~127 
	printf("%u\n%u\n", a, b);//输出的值是相同的，在char类型中127+1=128；因为127==01111111，+1后==10000000我们规定为-128
	//10000001其原码11111111为-127，10000010其原码为11111110为-126.......11111111原码为10000001为1 
	return 0;
} */
/*
#include<stdio.h>
int main()
{
	unsigned int i;
	for(i=9;i>=0;i--)
	{
		printf("%u\n", i);
	}
	return 0;
}*/
//计算一个字符数组的长度 
/*
#include<stdio.h>
#include<string.h>
int main()
{
	char a[1000];//char类型只能表示-128~127 
	int i = 0;
	for(i=0;i<1000;i++)
	{
		//char的存储范围是一个循环到达127后再+1就会变为-128；-128-1=127 
		a[i] = -1-i;//-1 -2 -3 .......-128 127 126 125......3 2 1 0 （识别到0strlen函数结束），原因看char类型范围的循环圈（微信截图图片） 
	}
	printf("%d\n", strlen(a));//255--0不计入 
	return 0;
}*/
//unsigned修饰过的字符类型 
/*
#include<stdio.h>
int main()
{
	unsigned char i = 0;//unsigned char类型的范围是0~255 
	for(i=0;i<=255;i++)//条件永远为真 
	{
		printf("%d\n", i);
	}
	return 0;
} 
*/
//浮点型在内存中的存储方式
#include<stdio.h>
int main()
{
	int a = 10;
	//int 10的二进制码为000000000000000000000000000001010 
	float* p = (float*)&a;
	//其翻译为浮点型为(-1)^0*0.000000000000000001010*2^-126无限接近于0，所以打印出的结果为0.0000000 
	printf("%d\n", a);//10
	printf("%f\n", *p);//0.000000
	*p = 10.0;
	//folat类型的*p二进制码为1010.0
	//其值翻译为(-1)^0*1.0100*2^3//其中(-1)^0代表符合位0为正1为负 
	//存储在内存中为0 10000010 01000000000000000000000//10000010是3+127的二进制 
	//十六进制为0x41200000 
	printf("%d\n", a);//所以a的值为0 00000101 00100000000000000000000 
	printf("%f\n", *p);
	return 0;
} 
